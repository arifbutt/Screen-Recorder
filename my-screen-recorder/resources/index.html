<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Screen Recorder â€” Full</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
<link href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css" rel="stylesheet">
<style>
  :root{--accent:#0d6efd;}
  body{background:#f8f9fa;color:#222;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial;transition:background .25s,color .25s;}
  .recorder-card{max-width:980px;margin:2rem auto;border-radius:12px;box-shadow:0 8px 30px rgba(20,20,40,.06);overflow:hidden;}
  header.app-header{padding:1.25rem 1.5rem;background:linear-gradient(90deg,rgba(13,110,253,0.06),transparent);display:flex;align-items:center;justify-content:space-between;}
  header.app-header h1{font-size:1.15rem;margin:0;display:flex;gap:.5rem;align-items:center;}
  .settings{padding:1.25rem;}
  .actions{padding:1rem;border-top:1px solid rgba(0,0,0,0.03);display:flex;gap:.75rem;align-items:center;}
  .toolbar{position:fixed;left:50%;transform:translateX(-50%);bottom:22px;background:#fff;border-radius:999px;padding:.5rem 1rem;box-shadow:0 8px 30px rgba(10,10,30,.08);display:none;z-index:9999;}
  .toolbar.dark{background:#1e1e1e;color:#f1f1f1;box-shadow:0 8px 30px rgba(0,0,0,.5);}
  .video-stage{background:#000;min-height:420px;display:flex;align-items:center;justify-content:center;position:relative;}
  .video-stage .stage-video{max-width:100%;max-height:100%;width:100%;height:100%;object-fit:contain;background:#111;}
  .preview-card{padding:1.25rem;display:none;}
  .dark-mode{background:#0b0b0c;color:#eee;}
  .dark-mode .recorder-card{background:#0f0f11;}
  .dark-mode header.app-header{background:linear-gradient(90deg,rgba(255,255,255,0.02),transparent);}
  .control-btn{width:46px;height:46px;border-radius:10px;display:inline-flex;align-items:center;justify-content:center;}
  .webcam-preview{position:absolute;width:220px;height:140px;border-radius:10px;overflow:hidden;background:#222;right:20px;bottom:20px;z-index:50;display:none;border:3px solid rgba(255,255,255,0.05);cursor:grab;}
  .webcam-preview.dragging{cursor:grabbing;}
  .cursor-highlight{position:fixed;pointer-events:none;width:56px;height:56px;border-radius:50%;transform:translate(-50%,-50%);mix-blend-mode:overlay;z-index:99998;display:none;}
  .click-effect{position:fixed;pointer-events:none;border-radius:50%;transform:translate(-50%,-50%);z-index:99997;opacity:0;display:none;}
  .note{font-size:0.85rem;color:#6c757d;}
  .form-label.small{font-size:0.85rem;}
  .quality-note{font-size:0.8rem;color:#6c757d;margin-top:.25rem;}
</style>
</head>
<body>
  <div class="card recorder-card">
    <header class="app-header d-flex align-items-center">
      <div>
        <h1>ðŸŽ¥ <strong>Screen Recorder</strong></h1>
        <div class="note">Record screen, microphone, optional webcam overlay, cursor highlighting.</div>
      </div>
      <div class="d-flex align-items-center gap-2">
        <div class="form-check form-switch me-2">
          <input class="form-check-input" id="darkToggle" type="checkbox">
          <label class="form-check-label" for="darkToggle">Dark</label>
        </div>
        <button id="helpBtn" class="btn btn-sm btn-outline-secondary">Help</button>
      </div>
    </header>

    <div class="row g-0">
      <div class="col-md-7">
        <div class="video-stage" id="videoStage">
          <video id="screenVideo" class="stage-video" autoplay muted playsinline></video>
          <div id="webcamPreview" class="webcam-preview" title="Drag to reposition">
            <video id="webcamVideo" autoplay muted playsinline style="width:100%;height:100%;object-fit:cover;"></video>
          </div>
          <canvas id="compositeCanvas" style="display:none;"></canvas>
          <div id="cursorHighlight" class="cursor-highlight" style="background:rgba(255,200,0,0.25);display:none;"></div>
          <div id="clickEffect" class="click-effect" style="background:rgba(255,200,0,0.2);display:none;"></div>
        </div>
        <div class="preview-card" id="previewCard">
          <h5>Preview & Save</h5>
          <video id="preview" controls style="width:100%;border-radius:8px;background:#000;"></video>
          <div class="d-flex justify-content-between mt-3">
            <button id="downloadBtn" class="btn btn-success"><i class="bi bi-download me-1"></i> Download</button>
            <button id="redoBtn" class="btn btn-outline-secondary"><i class="bi bi-arrow-repeat me-1"></i> Redo</button>
          </div>
        </div>
      </div>

      <div class="col-md-5">
        <div class="settings">
          <h5>Recording Settings</h5>
          <div class="form-check form-switch mt-3">
            <input class="form-check-input" type="checkbox" id="micToggle">
            <label class="form-check-label" for="micToggle">Include Microphone</label>
          </div>
          <div class="form-check form-switch mt-2">
            <input class="form-check-input" type="checkbox" id="webcamToggle">
            <label class="form-check-label" for="webcamToggle">Include Webcam</label>
          </div>

          <div class="mb-3 mt-2" id="webcamOptions" style="display:none;">
            <label class="form-label small">Webcam Position</label>
            <select id="webcamPos" class="form-select form-select-sm">
              <option value="br" selected>Bottom Right</option>
              <option value="bl">Bottom Left</option>
              <option value="tr">Top Right</option>
              <option value="tl">Top Left</option>
            </select>
            <div class="form-check form-switch mt-2">
              <input class="form-check-input" type="checkbox" id="webcamBorderToggle">
              <label class="form-check-label" for="webcamBorderToggle">Show Webcam Border</label>
            </div>
          </div>

          <div class="form-check form-switch mt-2">
            <input class="form-check-input" type="checkbox" id="cursorToggle">
            <label class="form-check-label" for="cursorToggle">Highlight Mouse Cursor</label>
          </div>

          <div class="mb-3 mt-3">
            <label class="form-label">Video Quality</label>
            <select id="quality" class="form-select form-select-sm">
              <option value="1080">High (1080p)</option>
              <option value="720" selected>Medium (720p)</option>
              <option value="480">Low (480p)</option>
            </select>
            <div class="quality-note">Higher quality = larger file & more CPU usage.</div>
          </div>

          <div class="actions">
            <button id="startBtn" class="btn btn-primary w-100"><i class="bi bi-record-circle me-1"></i> Start Recording</button>
          </div>
          <div class="mt-3 note">Tip: For best results choose "This window" or "Application window" when prompted to capture.</div>
        </div>
      </div>
    </div>

    <div class="actions" style="justify-content:space-between;">
      <div>
        <span class="me-3">Status: <strong id="statusLabel">idle</strong></span>
        <span class="me-3">Duration: <strong id="timer">00:00</strong></span>
      </div>
      <div>
        <button id="pauseBtn" class="btn btn-outline-secondary control-btn" title="Pause" style="display:none;"><i class="bi bi-pause-fill"></i></button>
        <button id="stopBtn" class="btn btn-outline-danger control-btn" title="Stop" style="display:none;"><i class="bi bi-stop-fill"></i></button>
        <button id="toggleWebcamBtn" class="btn btn-outline-primary control-btn" title="Toggle Webcam" style="display:none;"><i class="bi bi-camera-video"></i></button>
      </div>
    </div>
  </div>

<script>
/*
 Full screen recorder:
 - Captures screen via getDisplayMedia (video+optional system audio if browser allows)
 - Optionally captures microphone
 - Optionally captures webcam; if enabled, draw webcam into composite canvas on chosen position
 - Cursor highlight overlay drawn into canvas when enabled (best when recording the browser window)
 - Composite canvas is recorded via MediaRecorder (webm)
 - Audio tracks (mic and system) are merged into final recorded stream
 Notes & limitations:
 - Cursor overlay uses page mouse events; when recording a full external app, mouse outside page won't be tracked.
 - System audio capture depends on browser & user selection in getDisplayMedia prompt.
*/

// UI elements
const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const stopBtn = document.getElementById('stopBtn');
const toggleWebcamBtn = document.getElementById('toggleWebcamBtn');
const statusLabel = document.getElementById('statusLabel');
const timerLabel = document.getElementById('timer');
const previewCard = document.getElementById('previewCard');
const previewVideo = document.getElementById('preview');
const downloadBtn = document.getElementById('downloadBtn');
const redoBtn = document.getElementById('redoBtn');

const micToggle = document.getElementById('micToggle');
const webcamToggle = document.getElementById('webcamToggle');
const webcamOptions = document.getElementById('webcamOptions');
const webcamPosSel = document.getElementById('webcamPos');
const webcamBorderToggle = document.getElementById('webcamBorderToggle');
const cursorToggle = document.getElementById('cursorToggle');
const qualitySel = document.getElementById('quality');

const videoStage = document.getElementById('videoStage');
const screenVideo = document.getElementById('screenVideo');
const webcamVideo = document.getElementById('webcamVideo');
const webcamPreview = document.getElementById('webcamPreview');
const compositeCanvas = document.getElementById('compositeCanvas');
const cursorHighlight = document.getElementById('cursorHighlight');
const clickEffect = document.getElementById('clickEffect');
const videoStageRect = () => videoStage.getBoundingClientRect();

let screenStream = null;
let micStream = null;
let webcamStream = null;
let mediaRecorder = null;
let recordedChunks = [];
let canvasStream = null;
let mixedStream = null;
let drawInterval = null;
let startTime = null;
let timerInterval = null;

let dragging = false;
let dragOffset = {x:0,y:0};

// Dark mode
const darkToggle = document.getElementById('darkToggle');
darkToggle.addEventListener('change', () => {
  document.body.classList.toggle('dark-mode', darkToggle.checked);
  document.querySelector('.toolbar')?.classList.toggle('dark', darkToggle.checked);
});

// webcam options show/hide
webcamToggle.addEventListener('change', () => {
  webcamOptions.style.display = webcamToggle.checked ? 'block' : 'none';
  webcamPreview.style.display = webcamToggle.checked ? 'block' : 'none';
});

// draggable webcam preview
webcamPreview.addEventListener('mousedown', (e) => {
  dragging = true;
  webcamPreview.classList.add('dragging');
  dragOffset.x = e.clientX - webcamPreview.offsetLeft;
  dragOffset.y = e.clientY - webcamPreview.offsetTop;
});
document.addEventListener('mousemove', (e) => {
  if(dragging){
    let x = e.clientX - dragOffset.x;
    let y = e.clientY - dragOffset.y;
    // keep inside stage
    const rect = videoStage.getBoundingClientRect();
    x = Math.max(rect.left, Math.min(x, rect.right - webcamPreview.offsetWidth)) - rect.left;
    y = Math.max(rect.top, Math.min(y, rect.bottom - webcamPreview.offsetHeight)) - rect.top;
    webcamPreview.style.left = (x) + 'px';
    webcamPreview.style.top = (y) + 'px';
  }
  // move cursor highlight overlay
  if(cursorToggle.checked){
    cursorHighlight.style.display = 'block';
    cursorHighlight.style.left = e.clientX + 'px';
    cursorHighlight.style.top = e.clientY + 'px';
  }
});
document.addEventListener('mouseup', () => {
  if(dragging){ webcamPreview.classList.remove('dragging'); dragging = false; }
});

// click animation
document.addEventListener('click', (e)=>{
  if(cursorToggle.checked){
    clickEffect.style.display = 'block';
    clickEffect.style.left = e.clientX + 'px';
    clickEffect.style.top = e.clientY + 'px';
    clickEffect.style.width = '20px';
    clickEffect.style.height = '20px';
    clickEffect.style.opacity = '0.8';
    clickEffect.animate([
      {transform:'translate(-50%,-50%) scale(1)', opacity:0.8},
      {transform:'translate(-50%,-50%) scale(3)', opacity:0}
    ],{duration:450}).onfinish = ()=>{ clickEffect.style.display = 'none'; };
  }
});

// Start recording flow
startBtn.addEventListener('click', async () => {
  try{
    startBtn.disabled = true;
    statusLabel.textContent = 'starting...';
    const quality = parseInt(qualitySel.value,10) || 720;
    // request display stream (ask for audio too so system audio may be included)
    screenStream = await navigator.mediaDevices.getDisplayMedia({video:{frameRate:30}, audio:true});
    screenVideo.srcObject = screenStream;
    await screenVideo.play().catch(()=>{});

    // mic
    if(micToggle.checked){
      try{
        micStream = await navigator.mediaDevices.getUserMedia({audio:true, video:false});
      }catch(err){
        console.warn('Mic permission denied', err);
        micStream = null;
      }
    }

    // webcam
    if(webcamToggle.checked){
      try{
        webcamStream = await navigator.mediaDevices.getUserMedia({video:{width:320,height:240}, audio:false});
        webcamVideo.srcObject = webcamStream;
        await webcamVideo.play().catch(()=>{});
        webcamPreview.style.display = 'block';
      }catch(err){
        console.warn('Webcam denied', err);
        webcamStream = null;
        webcamPreview.style.display = 'none';
      }
    }

    // prepare canvas with chosen quality (width based on screen stream settings)
    const displayTrack = screenStream.getVideoTracks()[0];
    const settings = displayTrack.getSettings ? displayTrack.getSettings() : {};
    const screenW = settings.width || 1280;
    const screenH = settings.height || 720;
    // choose canvas size based on quality selection while maintaining aspect ratio
    let targetW = quality;
    let targetH = Math.round((screenH/screenW) * targetW);
    compositeCanvas.width = targetW;
    compositeCanvas.height = targetH;
    const ctx = compositeCanvas.getContext('2d');

    // draw loop: draw screen video, optional highlight, webcam overlay
    const screenVideoElement = screenVideo; // ensure reference
    const draw = () => {
      // draw screen
      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,compositeCanvas.width,compositeCanvas.height);
      try{
        ctx.drawImage(screenVideoElement, 0,0,compositeCanvas.width, compositeCanvas.height);
      }catch(e){ /* may fail until frame ready */ }

      // draw cursor highlight (if enabled) - map viewport coords to canvas coords
      if(cursorToggle.checked){
        const mx = parseFloat(cursorHighlight.style.left || '0');
        const my = parseFloat(cursorHighlight.style.top || '0');
        if(mx && my){
          const vw = window.innerWidth;
          const vh = window.innerHeight;
          const cx = (mx / vw) * compositeCanvas.width;
          const cy = (my / vh) * compositeCanvas.height;
          ctx.beginPath();
          ctx.fillStyle = 'rgba(255,200,0,0.35)';
          ctx.arc(cx, cy, Math.max(20, compositeCanvas.width * 0.03), 0, Math.PI*2);
          ctx.fill();
        }
      }

      // draw webcam overlay if available
      if(webcamStream && webcamVideo.readyState >= 2){
        // compute webcam size as percentage of canvas
        const ww = Math.round(compositeCanvas.width * 0.28);
        const wh = Math.round(ww * (webcamVideo.videoHeight / webcamVideo.videoWidth || 0.75));
        // compute position based on preview location OR selected pos
        const stageRect = videoStage.getBoundingClientRect();
        // if user dragged, use its offset relative to stage
        const previewRect = webcamPreview.getBoundingClientRect();
        let x, y;
        // if preview not visible, use selected pos
        if(webcamPreview.style.display === 'none'){
          const pos = webcamPosSel.value;
          if(pos === 'br'){ x = compositeCanvas.width - ww - 20; y = compositeCanvas.height - wh - 20; }
          else if(pos === 'bl'){ x = 20; y = compositeCanvas.height - wh - 20; }
          else if(pos === 'tr'){ x = compositeCanvas.width - ww - 20; y = 20; }
          else { x = 20; y = 20; }
        }else{
          // map previewRect left/top within stage to canvas coords
          const relX = previewRect.left - stageRect.left;
          const relY = previewRect.top - stageRect.top;
          const scaleX = compositeCanvas.width / stageRect.width;
          const scaleY = compositeCanvas.height / stageRect.height;
          x = Math.round(relX * scaleX);
          y = Math.round(relY * scaleY);
        }
        // optional border
        if(webcamBorderToggle.checked){
          // draw rounded rect background
          const radius = 12;
          ctx.fillStyle = 'rgba(0,0,0,0.45)';
          roundRect(ctx, x-4, y-4, ww+8, wh+8, radius);
          ctx.fill();
        }
        // draw webcam video
        try{
          ctx.drawImage(webcamVideo, x, y, ww, wh);
        }catch(e){}
      }

      // loop next frame
    };

    // helper roundRect
    function roundRect(ctx,x,y,w,h,r){ if(w<2*r) r=w/2; if(h<2*r) r=h/2; ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }

    // start drawing at ~30fps
    drawInterval = setInterval(() => { draw(); }, 1000/30);

    // capture canvas stream
    canvasStream = compositeCanvas.captureStream(30);

    // build final mixed stream: video from canvas + audio tracks from screen & mic (if available)
    mixedStream = new MediaStream();
    // add canvas video track
    canvasStream.getVideoTracks().forEach(t => mixedStream.addTrack(t));
    // add audio tracks
    if(screenStream.getAudioTracks().length) screenStream.getAudioTracks().forEach(t=>mixedStream.addTrack(t));
    if(micStream && micStream.getAudioTracks().length) micStream.getAudioTracks().forEach(t=>mixedStream.addTrack(t));

    // prepare MediaRecorder
    recordedChunks = [];
    const mime = MediaRecorder.isTypeSupported('video/webm;codecs=vp9,opus') ? 'video/webm;codecs=vp9,opus' :
                 MediaRecorder.isTypeSupported('video/webm;codecs=vp8,opus') ? 'video/webm;codecs=vp8,opus' : 'video/webm';
    mediaRecorder = new MediaRecorder(mixedStream, {mimeType:mime, videoBitsPerSecond: 2500000});
    mediaRecorder.ondataavailable = (e)=>{ if(e.data && e.data.size) recordedChunks.push(e.data); };
    mediaRecorder.onstart = ()=>{ onRecordingStarted(); };
    mediaRecorder.onpause = ()=>{ statusLabel.textContent = 'paused'; };
    mediaRecorder.onresume = ()=>{ statusLabel.textContent = 'recording'; };
    mediaRecorder.onstop = ()=>{ onRecordingStopped(); };
    mediaRecorder.start(1000);

    statusLabel.textContent = 'recording';
    startTime = Date.now();
    timerInterval = setInterval(updateTimer, 250);

    // show toolbar controls
    pauseBtn.style.display = 'inline-block';
    stopBtn.style.display = 'inline-block';
    toggleWebcamBtn.style.display = 'inline-block';
    document.querySelector('.toolbar').style.display = 'flex';

  }catch(err){
    console.error('Start failed', err);
    statusLabel.textContent = 'error';
    startBtn.disabled = false;
  } finally {
    startBtn.disabled = false;
  }
});

// Pause/resume
pauseBtn.addEventListener('click', ()=>{
  if(!mediaRecorder) return;
  if(mediaRecorder.state === 'recording'){ mediaRecorder.pause(); pauseBtn.innerHTML = '<i class="bi bi-play-fill"></i>'; statusLabel.textContent='paused'; }
  else if(mediaRecorder.state === 'paused'){ mediaRecorder.resume(); pauseBtn.innerHTML = '<i class="bi bi-pause-fill"></i>'; statusLabel.textContent='recording'; }
});

// Stop
stopBtn.addEventListener('click', ()=>{
  if(mediaRecorder && mediaRecorder.state !== 'inactive'){ mediaRecorder.stop(); }
  // stop draw loop and streams will be stopped in onRecordingStopped cleanup
});

// toggle webcam visibility (preview)
toggleWebcamBtn.addEventListener('click', ()=>{
  if(webcamPreview.style.display === 'none'){ webcamPreview.style.display = 'block'; } else { webcamPreview.style.display = 'none'; }
});

// on recording started
function onRecordingStarted(){
  statusLabel.textContent = 'recording';
  // hide preview card
  previewCard.style.display = 'none';
}

// on recording stopped
async function onRecordingStopped(){
  statusLabel.textContent = 'processing';
  // stop timer
  clearInterval(timerInterval);
  // stop draw interval
  if(drawInterval) clearInterval(drawInterval);
  // stop tracks
  try{ screenStream && screenStream.getTracks().forEach(t=>t.stop()); }catch(e){}
  try{ webcamStream && webcamStream.getTracks().forEach(t=>t.stop()); }catch(e){}
  try{ micStream && micStream.getTracks().forEach(t=>t.stop()); }catch(e){}
  // stop canvas tracks
  try{ canvasStream && canvasStream.getTracks().forEach(t=>t.stop()); }catch(e){}

  // create blob and show preview
  const blob = new Blob(recordedChunks, {type:'video/webm'});
  const url = URL.createObjectURL(blob);
  previewVideo.src = url;
  previewVideo.onloadedmetadata = ()=>{ previewVideo.play().catch(()=>{}); };
  previewCard.style.display = 'block';
  statusLabel.textContent = 'idle';
  timerLabel.textContent = '00:00';

  // show download handler
  downloadBtn.onclick = ()=>{
    const a = document.createElement('a');
    a.href = url;
    const ts = new Date().toISOString().replace(/[:.]/g,'-');
    a.download = `screen-recording-${ts}.webm`;
    document.body.appendChild(a);
    a.click();
    a.remove();
  };
}

// timer update
function updateTimer(){
  if(!startTime) return;
  const diff = Date.now() - startTime;
  const s = Math.floor(diff/1000)%60;
  const m = Math.floor(diff/60000);
  timerLabel.textContent = `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
}

// redo
redoBtn.addEventListener('click', ()=>{
  previewCard.style.display = 'none';
  recordedChunks = [];
  previewVideo.src = '';
});

// cleanup when leaving page
window.addEventListener('beforeunload', ()=>{
  try{ if(mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop(); }catch(e){}
});

</script>

</body>
</html>
